require import AllCore List Ring RealExp ZModP IntDiv Bigalg StdRing StdOrder FloorCeil.
require import Distr DInterval DList DMap.
require import Poly.
require PKE.


op k: int.

axiom leq4_k: 4 <= k.

type pkey.
op p_n: pkey -> int.
op p_e: pkey -> int.

type skey.
op s_d: skey -> int.
op s_p: skey -> int.
op s_q: skey -> int.
op s_n: skey -> int = fun sk,
  s_p sk * s_q sk.

(* Specification of a least common multiple *)
op lcm_spec a b = fun z =>
(1 <= z /\ a %| z /\ b %| a)
  /\ (forall x, a %| x => b %| x => z <= x).

(* Least common divisor between two numbers*)
op lcm a b = if (a, b) = (1, 1) then 1 else choiceb (gcd_spec a b) 0.

  (** They are generated by sampling in this distribution *)
type keypair = pkey * skey.
op keypairs: keypair distr.
axiom keypairsL: mu keypairs (fun s, true) = 1%r.

  (* Necessary conditions for (pk,sk) to be a valid keypair:
  *  - the public and private modulus are identical, and
  *  - the modulus is exactly k bits long                   *)
axiom valid_keypairs pk sk:
support keypairs (pk,sk) =>
p_n pk = s_n sk /\
  2^(k - 1) <= p_n pk < 2^k.

axiom primality_p sk:
prime (s_p sk).

axiom primality_q sk:
prime (s_q sk).

op pkey_eq pk1 pk2 = (p_n pk1 = p_n pk2) /\ (p_e pk1 = p_e pk2).
op skey_eq sk1 sk2 = (s_d sk1 = s_d sk2) /\ (s_p sk1 = s_p sk2) /\ (s_q sk1 = s_q sk2).

const SK: skey.
const PK: pkey.
axiom valid_global : support keypairs (PK, SK).

(* An adverseray trying to factor an rsa modulus n*)
module type RSA_factoring_adv = {
  proc factorize(pk: pkey): int * int
}.

module RSA_factoring_game(Adv: RSA_factoring_adv) = {

  proc main() = {
  var p': int;
  var q': int;

    (p', q') <@ Adv.factorize(PK);

      return ((p'*q') = p_n PK) && 1 < p' && p' < q' && q' < p_n PK;
  }
}.

module type RSA_GOP_adv = {
  proc compute_GO(pk: pkey): int
}.

module RSA_GOP(Adv: RSA_GOP_adv) = {

  proc main() = {
    var z: int;

    z <@ Adv.compute_GO(PK);

    return z = (s_p SK - 1)*(s_q SK - 1);
  }
}.

module GOP_using_FP(A: RSA_factoring_adv): RSA_GOP_adv = {
    proc compute_GO(pk: pkey): int = {
      var p: int;
      var q: int;
      (p, q) <@ A.factorize(pk);

      return (p-1)*(q-1);
  }
}.

section.
declare module A <: RSA_factoring_adv.
  (*lemma red2: equiv[RSA_factoring_game(A).main ~ RSA_GOP(B(A)).main : true ==> (res{1} => res{2})].
  proof.
  assume.
  *)

  (* TODO prove it*)
lemma RSAFP_to_GOP_red : equiv[RSA_factoring_game(A).main ~ RSA_GOP(GOP_using_FP(A)).main : true ==> res{1} => res{2}].
    admit.
  qed.

  end section.
(*
module FactGOP(AdvGop : RSA_GOP_adv) : RSA_factoring_adv = {
  proc factorize(pk: pkey): int * int = {
    var ply: Poly.ZPoly;
    return (9, 9);
    
  }
}.*)

module type RSAKRP_adv = {
  proc recover(pk: pkey): int
}.

module RSAKRP(A: RSAKRP_adv) = {
  proc main(): bool = {
    var d': int;
    d' <@ A.recover(PK);
    return d' = s_d SK;
  }
}.

module type RSADP_adv = {
  proc decrypt(n: int, e: int): int
}.

module RSADP(A: RSADP_adv) = {
  proc main(): bool = {
    var x: int;
    var y: int;
    var d': int;
    var x': int;

    x <$ [0..(2^k)];
    y <- (x ^ p_e PK) %% (p_n PK);

    d' <@ A.decrypt(p_n PK, p_e PK);
    x' <- (y ^ d') %% (p_n PK);

    return x = x';
  }
}.



(* EMP ==> RSAFP*)

(* An adverseray trying to compute the Carmicheal value of n *)
module type RSA_EMP_adv = {
  proc lambda(pk: pkey): int
}.

module RSA_EMP_game(Adv: RSA_EMP_adv) = {
  proc main() = {
  var z: int;

  z <@ Adv.lambda(PK);

  return ((z = lcm (s_p SK) (s_q SK)) && z <> 0);
  }
}.

(* At this point we have to implement the factorization using lambda...
    module EMP_using_LMBDA(A: RSA_EMP_adv): RSA_EMP_adv = {
    proc compute_GO(pk: pkey): int = {
    var p: int;
    var q: int;
    z <@ A.lambda(pk);

    return (p-1)*(q-1);
    }
    }.
*)

(* RSAKRP ==> EMP *)

module KRP_using_EMP(A: RSA_EMP_adv): RSAKRP_adv = {
  proc recover(pk: pkey): int = {
    var d: int;
    var e: int;
    d <@ A.lambda(pk);
    e <- (p_e pk);

  return e * d - 1;
  }
}.

section.
declare module A <: RSA_EMP_adv.
  (*lemma red2: equiv[RSA_factoring_game(A).main ~ RSA_GOP(B(A)).main : true ==> (res{1} => res{2})].
  proof.
  assume.
  *)

  (* TODO prove it*)
lemma EMP_to_RSAKRP_red : equiv[RSA_EMP_game(A).main ~ RSAKRP(KRP_using_EMP(A)).main : true ==> res{1} => res{2}].
    admit.
  qed.

  end section.
