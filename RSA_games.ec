require import AllCore List Ring RealExp ZModP IntDiv Bigalg StdRing StdOrder FloorCeil.
require import Distr DInterval DList DMap.
require import Poly.
require PKE.


op k: int.

axiom leq4_k: 4 <= k.

type pkey.
op p_n: pkey -> int.
op p_e: pkey -> int.

type skey.
op s_d: skey -> int.
op s_p: skey -> int.
op s_q: skey -> int.
op s_n: skey -> int = fun sk,
  s_p sk * s_q sk.

(* Specification of a least common multiple *)
op lcm_spec a b = fun z =>
(1 <= z /\ a %| z /\ b %| a)
  /\ (forall x, a %| x => b %| x => z <= x).

(* Least common divisor between two numbers*)
op lcm a b = if (a, b) = (0, 0) then 0 else choiceb (lcm_spec a b) 0.

(* Since lcm is not defnied in the standard library we have to prove some properties ourself *)
lemma lcm_divides_ab a b: lcm a b %| a*b.
    admit.
qed.
    (*have a_divide_ab : a %| a*b.
    smt wantedlemmas=dvdzP.
    have b_divide_ab : b %| a*b.
    smt wantedlemmas=dvdzP.
    have jsp : (lcm a b <= a*b).
    move=> @/ lcm.
    case: ((a, b) = (0, 0)).
    trivial.
    move=> ?.
    move=> @/lcm_spec.
    smt timeout=20.
    trivia
    smt all timeout=10.
    smt all timeout=10.*)


(* Inverse modulo n operator *)
op inv_mod x n = choiceb (fun y: int  => y * x %% n = 1) x.


  (** They are generated by sampling in this distribution *)
type keypair = pkey * skey.
op keypairs: keypair distr.
axiom keypairsL: mu keypairs (fun s, true) = 1%r.

  (* Necessary conditions for (pk,sk) to be a valid keypair:
  *  - the public and private modulus are identical, and
  *  - the modulus is exactly k bits long                   *)
axiom valid_keypairs pk sk:
support keypairs (pk,sk) =>
p_n pk = s_n sk /\
  (* right key length *)
  2^(k - 1) <= p_n pk < 2^k /\
  (* p != q && prime p and q *)
  prime (s_p sk) && s_p sk < s_q sk && prime (s_q sk) /\
  (* e > 1 otherwise there is no encryption at all... *)
  1 < (p_e pk).


(* Define an arbitrary keypair as a global constant, to make sure we are always considering the same in each problems *)
const SK: skey.
const PK: pkey.
axiom valid_global : support keypairs (PK, SK).

(* An adverseray trying to factor an rsa modulus n*)
module type RSAFP_adv = {
  proc factorize(n: int): int * int
}.

module RSAFP_game(Adv: RSAFP_adv) = {

  proc main() = {
  var p': int;
  var q': int;

    (p', q') <@ Adv.factorize(p_n PK);

      return ((p'*q') = p_n PK) && 1 < p' && p' < q' && q' < p_n PK;
  }
}.

module type RSAGOP_adv = {
  proc compute_GO(n: int): int
}.

module RSAGOP_game(Adv: RSAGOP_adv) = {

  proc main() = {
    var z: int;

    z <@ Adv.compute_GO(p_n PK);

    return z = (s_p SK - 1)*(s_q SK - 1);
  }
}.

module RSAGOP_using_RSAFP(A: RSAFP_adv): RSAGOP_adv = {
  proc compute_GO(n: int): int = {
  var p: int;
  var q: int;
    (p, q) <@ A.factorize(n);

      return (p-1)*(q-1);
  }
}.

(* RSAFP ==> RSAGOP *)
lemma PK_SK_equiv : (p_n PK = s_p SK * s_q SK).
    have SK_n : s_n SK = s_p SK * s_q SK.
    smt.
    rewrite - SK_n.
    smt all.
    qed.


(* We will put that as an axiom... it is basically an application of the fundamental theorem of arithmetic *)
axiom n_factors_are_p_q : forall (p, q: int), p*q = p_n PK && 1 < p && p < q && q < p_n PK
    => (p = s_p SK && q = s_q SK).

lemma RSAFP_to_RSAGOP_red (A <: RSAFP_adv) &m:
    Pr[RSAFP_game(A).main() @ &m : res] <= Pr[RSAGOP_game(RSAGOP_using_RSAFP(A)).main() @ &m : res].
proof.
   byequiv=>//. (* Split the pRHL judgement into three goals. The right part already solve two goals *)
   proc; inline *. (* Put the code of the game instead of the return value *)
   wp. (* Replace trivial assignement in post condition (si z{2} = ...) *)
   call (_: true). (* Do strange thing but the specific case with "true" move the concrete program into the postcondition *)
   auto. (* Clean the precondition, we do not need n anymore*)
   move=> &1 &2 A_eq_m. (* Move in the assumption the part of the conclusion that say that that both program have the same memory *)
   simplify. (* simplify the trivial n = n *)
   split. (* Split the different conjuncts of the conclusion (2 goals now) *)
   smt. (* The first goal said that both Adversary are the same in the memory of both program (which is obvious => can be solved by a smt). We are left we only one goal: suppose the adversary is the same on both side, prove the correctness of the reduction. *)
   move=> same_A. (* Move the assume part (adversary is the same) into the assumption and called this "lemma same_A" *)
   move=> res_L res_R A_L A_R. (* Move all universally quantified variable into the assumption as arbitrary variables*)
   move=>  eq_res success_FP. (* Now we are left with result of both program are the same and they share same adversary implies correctness of the reduction. Move the first part into the assumption.*)
  have eq_p_L_R : (res_R.`1 = res_L.`1). (* Create a sub goal claiming that p are the same in both programs*)
   smt. (* Solve it by SMT *)
   have eq_q_L_R : (res_R.`2 = res_L.`2). (* Same for q *)
   smt.
   rewrite eq_p_L_R. (* Use the lemmas we just defined to replace p in the conclusion by the p of the left program*)
   rewrite eq_q_L_R. (* Do the same for q *)
   have factorization : (p_n PK = (s_p SK)*(s_q SK)). (* Create a lemma saying that pk.n = sk.p * sk.q *)
   smt. (* Solve it by smt *)
   (* Cleanup this mess a bit *)
  clear A &m &1 &2 A_eq_m same_A A_L A_R eq_res eq_p_L_R eq_q_L_R res_R. (* Remove all useless lemmas*)
   (* Here we use the previous lemma and it works *)
   (* Also make sure the timeout is big enough, it took ~6 seconds on my computer *)
   smt all timeout=10.
qed.


(*
module FactGOP(AdvGop : RSA_GOP_adv) : RSA_factoring_adv = {
  proc factorize(pk: pkey): int * int = {
    var ply: Poly.ZPoly;
    return (9, 9);
    
  }
}.*)

module type RSAKRP_adv = {
  proc recover(n: int, e: int): int
}.

module RSAKRP_game(A: RSAKRP_adv) = {
  proc main(): bool = {
    var d': int;
    d' <@ A.recover(p_n PK, p_e PK);
    return d' = s_d SK;
  }
}.


module type RSADP_adv = {
  proc decrypt(n: int, e: int, y: int): int
}.

module RSADP_game(A: RSADP_adv) = {
  proc main(): bool = {
    var x: int;
    var y: int;
    var z: int;

    x <$ [0..(2^k)];
    y <- (x ^ p_e PK) %% (p_n PK);

    z <@ A.decrypt(p_n PK, p_e PK, y);

     return x = z;
  }
}.

module RSADP_using_RSAKRP(A: RSAKRP_adv): RSADP_adv = {
  proc decrypt(n: int, e: int, y: int): int = {
  var d: int;
    var x: int;
  d <@ A.recover(p_n PK, p_e PK);
  x <- (y ^ d) %% (p_n PK);
  return x;
  }
}.

 (* RSAKRP ==> RSADP *)

axiom correctness : forall (x : int), (0 <= x && x <= 2^k) => ((x ^ p_e PK %% p_n PK) ^ s_d SK %% p_n PK) = x.
lemma RSAKRP_to_RSADP_red(A <: RSAKRP_adv) &m :
    Pr[RSAKRP_game(A).main() @ &m : res] <= Pr[RSADP_game(RSADP_using_RSAKRP(A)).main() @ &m : res].
proof.
  byequiv=>//.
  proc.
  inline *.
  auto=>/=.
  call (_: true).
  simplify.
  wp.
  rnd{2}.
  auto.
  (* Requires correctness *)
  smt.
qed.


(* An adverseray trying to compute the Carmicheal value of n *)
module type RSAEMP_adv = {
  proc lambda(n: int): int
}.

module RSAEMP_game(Adv: RSAEMP_adv) = {
  proc main() = {
  var z: int;

  z <@ Adv.lambda(p_n PK);

  (* TODO define lambda *)
  return ((lcm (s_p SK - 1) (s_q SK - 1)) %| z && z <> 0);
  }
}.

(* At this point we have to implement the factorization using lambda...
    module EMP_using_LMBDA(A: RSA_EMP_adv): RSA_EMP_adv = {
    proc compute_GO(pk: pkey): int = {
    var p: int;
    var q: int;
    z <@ A.lambda(pk);

    return (p-1)*(q-1);
    }
    }.
*)

(* EMP ==> RSAFP*)
(* TODO: EMPT1Y *)

module RSAEMP_using_RSAKRP(A: RSAKRP_adv): RSAEMP_adv = {
  proc lambda(n: int): int = {
    var d: int;
    var e: int;
    e <- p_e PK;
    d <@ A.recover(n, e);

  return e * d - 1;
  }
}.

(* RSAKRP ==> EMP *)
lemma RSAKRP_to_RSAEMP_red(A <: RSAKRP_adv) &m : Pr[RSAKRP_game(A).main() @ &m : res] <= Pr[RSAEMP_game(RSAEMP_using_RSAKRP(A)).main() @ &m : res].
proof.
byequiv=>//.
proc; inline *.
wp.
call (_ : true).
sp.
auto.
move=> &1 &2 A_win.
split.
smt.
move=> ? result_L result_R ? ? ? ?.
have right_d : result_R = s_d SK by smt.
rewrite right_d.
have right_e : e{2} = p_e PK by smt.
rewrite right_e.
split.
have inverse_def : exists k, p_e PK * s_d SK - 1 = k*((s_p SK - 1)*(s_q SK - 1)).
(*TODO prove this subgoal *)
admit.
have jsp: forall (k : int), lcm (s_p SK - 1) (s_q SK - 1) %| k*((s_p SK - 1)*(s_q SK - 1)).
  have jsp2: lcm (s_p SK - 1) (s_q SK - 1) %| (s_p SK - 1)*(s_q SK - 1).
  by smt.
  move: jsp2.
  move /dvdz_mull.
  trivial.
move: inverse_def.
smt.
smt all timeout=10.
qed.


 module RSAKRP_using_RSAGOP(A: RSAGOP_adv): RSAKRP_adv = {
    proc recover(n: int, e: int): int = {
   var z: int;
   var d: int;
     z <@ A.compute_GO(n);
     d <- inv_mod e z;

     return d;
    }
  }.

 (* RSAGOP ==> RSAKRP *)
  section.
  declare module A <: RSAGOP_adv.

    (* TODO prove it*)
lemma RSAGOP_to_RSAKRP_red : equiv[RSAGOP_game(A).main ~ RSAKRP_game(RSAKRP_using_RSAGOP(A)).main : true ==> res{1} => res{2}].
    admit.
  qed.

  end section.
