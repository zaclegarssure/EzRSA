require import AllCore List Ring RealExp ZModP IntDiv Bigalg StdRing StdOrder FloorCeil.
require import Distr DInterval DList DMap.
require PKE.

op k: int.

axiom leq4_k: 4 <= k.

type pkey.
op p_n: pkey -> int.
op p_e: pkey -> int.

type skey.
op s_d: skey -> int.
op s_p: skey -> int.
op s_q: skey -> int.
op s_n: skey -> int = fun sk,
  s_p sk * s_q sk.

  (** They are generated by sampling in this distribution *)
type keypair = pkey * skey.
op keypairs: keypair distr.
axiom keypairsL: mu keypairs (fun s, true) = 1%r.

  (* Necessary conditions for (pk,sk) to be a valid keypair:
  *  - the public and private modulus are identical, and
  *  - the modulus is exactly k bits long                   *)
axiom valid_keypairs pk sk:
support keypairs (pk,sk) =>
p_n pk = s_n sk /\
  2^(k - 1) <= p_n pk < 2^k.

axiom primality_p sk:
prime (s_p sk).

axiom primality_q sk:
prime (s_q sk).

op pkey_eq pk1 pk2 = (p_n pk1 = p_n pk2) /\ (p_e pk1 = p_e pk2).
op skey_eq sk1 sk2 = (s_d sk1 = s_d sk2) /\ (s_p sk1 = s_p sk2) /\ (s_q sk1 = s_q sk2).

const SK: skey.
const PK: pkey.
axiom valid_global : support keypairs (PK, SK).

(* An adverseray trying to factor an rsa modulus n*)
module type RSA_factoring_adv = {
  proc factorize(pk: pkey): int * int
}.

module RSA_factoring_game(Adv: RSA_factoring_adv) = {
  (*var pk: pkey
  var sk: skey*)

  proc main() = {
    var p': int;
    var q': int;

    (*(pk, sk) <$ keypairs;*)

    (p', q') <@ Adv.factorize(PK);

    return ((p'*q') = p_n PK) && 1 < p' && p' < q' && q' < p_n PK;
  }
}.

module type RSA_GOP_adv = {
  proc compute_GO(pk: pkey): int
}.

module RSA_GOP(Adv: RSA_GOP_adv) = {
  (*var pk: pkey
  var sk: skey*)

  proc main() = {
    var z: int;

    (*(pk, sk) <$ keypairs;*)
    z <@ Adv.compute_GO(PK);

    return z = (s_p SK - 1)*(s_q SK - 1);
  }
}.

module B(A: RSA_factoring_adv): RSA_GOP_adv = {
    proc compute_GO(pk: pkey): int = {
      var p: int;
      var q: int;
      (p, q) <@ A.factorize(pk);

      return (p-1)*(q-1);
    }
 }.

section.
declare module A <: RSA_factoring_adv.
(*lemma red2: equiv[RSA_factoring_game(A).main ~ RSA_GOP(B(A)).main : true ==> (res{1} => res{2})].
    proof.
    assume.
  *)

lemma simple_red : equiv[RSA_factoring_game(A).main ~ RSA_GOP(B(A)).main : true ==> res{1} => res{2}].
proof.
proc.
inline *.
simplify.
auto.
apply valid_global.
trivial.
smt.

(* Reduction from factoring to GOP, when using B(A) as an adversary.
  The precondition is that we consider the same parameters in both games, and that those are valid*)
lemma red : equiv[RSA_factoring_game(A).main ~ RSA_GOP(B(A)).main :
      (pkey_eq RSA_factoring_game.pk{1} RSA_GOP.pk{2})
      /\ (skey_eq RSA_factoring_game.sk{1} RSA_GOP.sk{2})
      /\ (support keypairs (RSA_factoring_game.pk{1}, RSA_factoring_game.sk{1}))
      /\ (support keypairs (RSA_GOP.pk{2}, RSA_GOP.sk{2}))
      ==> res{1} => res{2}].
proof.
progress.
proc.
inline *.
auto.
move=> ->.
smt.

smt.
apply valid_keypairs.
reflexivity.
rewrite pkey_eq.
inline pkey_eq.
smt.

lemma reduction &m: Pr[RSA_factoring_game(A).main() @ &m: res] <= Pr[RSA_GOP(B(A)).main() @ &m: res].
    proof.
    proof.
    byequiv.
    proc.
    inline *.
    auto.
    simplify.
    trivial.
    wp.
    sp.
    auto.
    rnd.
    smt.
    seq 1 1.
    rewrite.
    subst pk.
    by smt.
    rewrite main.
    simplify.
    proc;
    inline *.
    do 2.
    trivial.
    auto.
    smt.
    qed.
    proc.
    inline *.

end section.
