require import AllCore List Ring RealExp ZModP IntDiv Bigalg StdRing StdOrder FloorCeil.
require import Distr DInterval DList DMap.
require PKE.

op k: int.

axiom leq4_k: 4 <= k.

type pkey.
op p_n: pkey -> int.
op p_e: pkey -> int.

type skey.
op s_d: skey -> int.
op s_p: skey -> int.
op s_q: skey -> int.
op s_n: skey -> int = fun sk,
  s_p sk * s_q sk.

  (** They are generated by sampling in this distribution *)
type keypair = pkey * skey.
op keypairs: keypair distr.
axiom keypairsL: mu keypairs (fun s, true) = 1%r.

  (* Necessary conditions for (pk,sk) to be a valid keypair:
  *  - the public and private modulus are identical, and
  *  - the modulus is exactly k bits long                   *)
axiom valid_keypairs pk sk:
support keypairs (pk,sk) =>
p_n pk = s_n sk /\
  2^(k - 1) <= p_n pk < 2^k.

axiom primality_p sk:
prime (s_p sk).

axiom primality_q sk:
prime (s_q sk).

op key_eq pk1 pk2 = (p_n pk1 = p_n pk2) && (p_e pk1 = p_e pk2).

(* An adverseray trying to factor an rsa modulus n*)
module type RSA_factoring_adv = {
  proc factorize(pk: pkey): int * int
}.

module RSA_factoring_game(Adv: RSA_factoring_adv) = {
  proc main() = {
    var pk: pkey;
    var sk: skey;
    var p': int;
    var q': int;

    (pk, sk) <$ keypairs;

    (p', q') <@ Adv.factorize(pk);

    return ((p'*q') = p_n pk) && 1 < p' && p' < q' && q' < p_n pk;
  }
}.

module type RSA_GOP_adv = {
  proc compute_GO(pk: pkey): int
}.

module RSA_GOP(Adv: RSA_GOP_adv) = {
  proc main() = {
    var pk: pkey;
    var sk: skey;
    var z: int;

    (pk, sk) <$ keypairs;
    z <@ Adv.compute_GO(pk);

    return z = (s_p sk - 1)*(s_q sk - 1);
  }
}.

module B(A: RSA_factoring_adv): RSA_GOP_adv = {
    proc compute_GO(pk: pkey): int = {
      var p: int;
      var q: int;
      (p, q) <@ A.factorize(pk);

      return (p-1)*(q-1);
    }
 }.
